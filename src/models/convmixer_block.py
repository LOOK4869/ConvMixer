"""
ConvMixer Model Implementation - ConvMixer Block

Based on: "Patches Are All You Need?" by Trockman & Kolter (2022)

This file implements the ConvMixer Block, which consists of:
1. Depthwise Convolution (spatial mixing) with residual connection
2. Pointwise Convolution (channel mixing)

Date: 12/07/2025
Written by Zehao Li <zl3667@columbia.edu>

The code has not been generated by AI tools, or copied from an exteranal resource.
"""

import torch
import torch.nn as nn


class ConvMixerBlock(nn.Module):
    """
    ConvMixer Block.
    
    The block performs two mixing operations:
    1. Spatial mixing: Depthwise convolution with large kernel
       - Uses residual connection
    2. Channel mixing: Pointwise (1x1) convolution
    
    According to the paper:
    z'_l = BN(σ{ConvDepthwise(z_{l-1})}) + z_{l-1}  (with residual)
    z_{l+1} = BN(σ{ConvPointwise(z'_l)})            (without residual)
    
    Args:
        dim: Number of channels (embedding dimension)
        kernel_size: Kernel size for depthwise convolution
    """
    
    def __init__(self, dim, kernel_size=9):
        super(ConvMixerBlock, self).__init__()
        
        self.dim = dim
        self.kernel_size = kernel_size
        
        # Depthwise convolution for spatial mixing
        # groups=dim means each channel is convolved independently
        self.depthwise_conv = nn.Conv2d(
            dim, dim,
            kernel_size=kernel_size,
            groups=dim,  # This makes it depthwise
            padding='same'  # Maintain spatial dimensions
        )
        self.act1 = nn.GELU()
        self.bn1 = nn.BatchNorm2d(dim)
        
        # Pointwise (1x1) convolution for channel mixing
        self.pointwise_conv = nn.Conv2d(dim, dim, kernel_size=1)
        self.act2 = nn.GELU()
        self.bn2 = nn.BatchNorm2d(dim)
    
    def forward(self, x):
        """
        Forward pass.
        
        Args:
            x: Input tensor of shape (batch, dim, H, W)
        
        Returns:
            Output tensor of shape (batch, dim, H, W)
        """
        # Spatial mixing with residual connection
        residual = x
        x = self.depthwise_conv(x)
        x = self.act1(x)
        x = self.bn1(x)
        x = x + residual  # Residual connection
        
        # Channel mixing (no residual as per paper's ablation study)
        x = self.pointwise_conv(x)
        x = self.act2(x)
        x = self.bn2(x)
        
        return x


def test_convmixer_block():
    """Test the ConvMixerBlock module."""
    print("Testing ConvMixerBlock...")
    
    # Test configurations
    configs = [
        {'dim': 256, 'kernel_size': 3, 'spatial_size': 32},
        {'dim': 256, 'kernel_size': 5, 'spatial_size': 32},
        {'dim': 256, 'kernel_size': 7, 'spatial_size': 32},
        {'dim': 256, 'kernel_size': 9, 'spatial_size': 32},
        {'dim': 768, 'kernel_size': 9, 'spatial_size': 32},
    ]
    
    for cfg in configs:
        block = ConvMixerBlock(
            dim=cfg['dim'],
            kernel_size=cfg['kernel_size']
        )
        
        # Create dummy input
        x = torch.randn(2, cfg['dim'], cfg['spatial_size'], cfg['spatial_size'])
        
        # Forward pass
        out = block(x)
        
        print(f"  dim={cfg['dim']}, kernel_size={cfg['kernel_size']}")
        print(f"    Input: {x.shape} -> Output: {out.shape}")
        
        # Verify output shape matches input shape
        assert out.shape == x.shape, f"Shape mismatch! Expected {x.shape}, got {out.shape}"
        
        # Count parameters
        params = sum(p.numel() for p in block.parameters())
        print(f"    Parameters: {params:,}")
    
    print("\nAll ConvMixerBlock tests passed!")


def analyze_block_parameters(dim, kernel_size):
    """
    Analyze the parameter breakdown of a ConvMixer block.
    
    According to the paper, each block has:
    - Depthwise conv: k^2 * dim + dim (weights + bias)
    - BN1: 2 * dim (gamma, beta)
    - Pointwise conv: dim * dim + dim (weights + bias)
    - BN2: 2 * dim (gamma, beta)
    """
    print(f"\nParameter analysis for dim={dim}, kernel_size={kernel_size}:")
    
    depthwise = kernel_size * kernel_size * dim + dim
    bn1 = 2 * dim
    pointwise = dim * dim + dim
    bn2 = 2 * dim
    total = depthwise + bn1 + pointwise + bn2
    
    print(f"  Depthwise conv: {depthwise:,}")
    print(f"  BatchNorm 1: {bn1:,}")
    print(f"  Pointwise conv: {pointwise:,}")
    print(f"  BatchNorm 2: {bn2:,}")
    print(f"  Total: {total:,}")
    
    # Verify with actual model
    block = ConvMixerBlock(dim, kernel_size)
    actual = sum(p.numel() for p in block.parameters())
    print(f"  Actual (from model): {actual:,}")
    
    return total


if __name__ == "__main__":
    test_convmixer_block()
    analyze_block_parameters(256, 9)
